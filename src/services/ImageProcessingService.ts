import { spawn } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import sharp from "sharp";
import { logger } from "../logger";
import { Config } from "../config";

export interface ImageGenerationConfig {
  prompt: string;
  width?: number;
  height?: number;
  aspectRatio?: "16:9" | "9:16" | "1:1" | "4:3" | "3:4";
  quality?: "standard" | "hd" | "ultra";
  seed?: number;
  steps?: number;
  guidance?: number;
  style?: "photographic" | "digital-art" | "comic-book" | "fantasy-art" | "analog-film" | "neon-punk" | "isometric" | "low-poly" | "origami" | "line-art" | "craft-clay" | "cinematic" | "3d-model" | "pixel-art";
}

export interface ImageEnhancementConfig {
  upscale?: number; // 2x, 4x
  denoising?: boolean;
  sharpening?: boolean;
  colorEnhancement?: boolean;
  backgroundRemoval?: boolean;
}

export interface ImageProcessingResult {
  success: boolean;
  outputPath?: string;
  width?: number;
  height?: number;
  error?: string;
  processingTime?: number;
}

export class ImageProcessingService {
  private stabilityApiKey?: string;
  private openaiApiKey?: string;

  constructor(private config: Config) {
    this.stabilityApiKey = process.env.STABILITY_API_KEY;
    this.openaiApiKey = process.env.OPENAI_API_KEY;
  }

  /**
   * Generate an image from text prompt using available AI services
   */
  public async generateImage(
    config: ImageGenerationConfig,
    outputPath: string
  ): Promise<ImageProcessingResult> {
    const startTime = Date.now();
    
    try {
      logger.info({ config, outputPath }, "Starting image generation");

      // Ensure output directory exists
      await fs.mkdir(path.dirname(outputPath), { recursive: true });

      // Try different services in order of preference
      let result: ImageProcessingResult;

      if (this.stabilityApiKey) {
        result = await this.generateWithStability(config, outputPath);
      } else if (this.openaiApiKey) {
        result = await this.generateWithOpenAI(config, outputPath);
      } else {
        // Fallback to local generation if available
        result = await this.generateLocalFallback(config, outputPath);
      }

      if (result.success) {
        result.processingTime = Date.now() - startTime;
        logger.info({ outputPath, processingTime: result.processingTime }, "Image generation completed");
      }

      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error({ error: errorMessage, config }, "Image generation failed");
      
      return {
        success: false,
        error: errorMessage,
        processingTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Generate image using Stability AI
   */
  private async generateWithStability(
    config: ImageGenerationConfig,
    outputPath: string
  ): Promise<ImageProcessingResult> {
    const { width = 1024, height = 1024 } = this.getImageDimensions(config);
    
    const requestBody = {
      text_prompts: [{ text: config.prompt }],
      width,
      height,
      samples: 1,
      steps: config.steps || 30,
      cfg_scale: config.guidance || 7,
      seed: config.seed,
      style_preset: config.style || "photographic",
    };

    try {
      const response = await fetch(
        "https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.stabilityApiKey}`,
            Accept: "application/json",
          },
          body: JSON.stringify(requestBody),
        }
      );

      if (!response.ok) {
        throw new Error(`Stability API error: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.artifacts && result.artifacts.length > 0) {
        const imageData = result.artifacts[0].base64;
        const buffer = Buffer.from(imageData, "base64");
        await fs.writeFile(outputPath, buffer);

        // Get image dimensions
        const metadata = await sharp(buffer).metadata();

        return {
          success: true,
          outputPath,
          width: metadata.width,
          height: metadata.height,
        };
      } else {
        throw new Error("No image generated by Stability AI");
      }

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.warn({ error: errorMessage }, "Stability AI generation failed");
      throw error;
    }
  }

  /**
   * Generate image using OpenAI DALL-E
   */
  private async generateWithOpenAI(
    config: ImageGenerationConfig,
    outputPath: string
  ): Promise<ImageProcessingResult> {
    const size = this.getOpenAIImageSize(config);
    const quality = config.quality === "ultra" ? "hd" : "standard";

    try {
      const response = await fetch("https://api.openai.com/v1/images/generations", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.openaiApiKey}`,
        },
        body: JSON.stringify({
          model: "dall-e-3",
          prompt: config.prompt,
          size,
          quality,
          n: 1,
          response_format: "url",
        }),
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.data && result.data.length > 0) {
        const imageUrl = result.data[0].url;
        
        // Download the image
        const imageResponse = await fetch(imageUrl);
        if (!imageResponse.ok) {
          throw new Error(`Failed to download generated image: ${imageResponse.status}`);
        }

        const buffer = Buffer.from(await imageResponse.arrayBuffer());
        await fs.writeFile(outputPath, buffer);

        // Get image dimensions
        const metadata = await sharp(buffer).metadata();

        return {
          success: true,
          outputPath,
          width: metadata.width,
          height: metadata.height,
        };
      } else {
        throw new Error("No image generated by OpenAI");
      }

    } catch (error) {
      logger.warn({ error: (error as Error).message }, "OpenAI generation failed");
      throw error;
    }
  }

  /**
   * Fallback local image generation (placeholder/solid color)
   */
  private async generateLocalFallback(
    config: ImageGenerationConfig,
    outputPath: string
  ): Promise<ImageProcessingResult> {
    logger.warn("No AI image generation service available, creating placeholder image");
    
    const { width = 1024, height = 1024 } = this.getImageDimensions(config);
    
    // Generate a simple gradient or solid color based on the prompt
    const colors = this.extractColorsFromPrompt(config.prompt);
    
    const image = sharp({
      create: {
        width,
        height,
        channels: 3,
        background: colors.primary,
      },
    });

    // Add some visual interest with a gradient effect
    const gradientSvg = `
      <svg width="${width}" height="${height}">
        <defs>
          <radialGradient id="grad" cx="50%" cy="50%" r="50%">
            <stop offset="0%" style="stop-color:${colors.primary};stop-opacity:0.8" />
            <stop offset="100%" style="stop-color:${colors.secondary};stop-opacity:1" />
          </radialGradient>
        </defs>
        <rect width="100%" height="100%" fill="url(#grad)" />
        <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="24" 
              fill="white" text-anchor="middle" dominant-baseline="middle">
          ${config.prompt.substring(0, 50)}...
        </text>
      </svg>
    `;

    await image
      .composite([{ input: Buffer.from(gradientSvg), top: 0, left: 0 }])
      .jpeg({ quality: 90 })
      .toFile(outputPath);

    return {
      success: true,
      outputPath,
      width,
      height,
    };
  }

  /**
   * Enhance an existing image using various processing techniques
   */
  public async enhanceImage(
    inputPath: string,
    config: ImageEnhancementConfig,
    outputPath: string
  ): Promise<ImageProcessingResult> {
    const startTime = Date.now();

    try {
      logger.info({ inputPath, config, outputPath }, "Starting image enhancement");

      // Verify input file exists
      await fs.access(inputPath);
      
      // Ensure output directory exists
      await fs.mkdir(path.dirname(outputPath), { recursive: true });

      let image = sharp(inputPath);
      const metadata = await image.metadata();

      // Apply enhancements
      if (config.upscale && config.upscale > 1) {
        const newWidth = Math.floor((metadata.width || 0) * config.upscale);
        const newHeight = Math.floor((metadata.height || 0) * config.upscale);
        image = image.resize(newWidth, newHeight, {
          kernel: sharp.kernel.lanczos3,
        });
      }

      if (config.sharpening) {
        image = image.sharpen(1, 1, 2);
      }

      if (config.colorEnhancement) {
        image = image.modulate({
          brightness: 1.05,
          saturation: 1.1,
        });
      }

      if (config.denoising) {
        // Basic noise reduction using blur and sharpen combination
        image = image.blur(0.5).sharpen(0.5, 0.5, 1);
      }

      // Save the enhanced image
      await image.jpeg({ quality: 95 }).toFile(outputPath);

      const finalMetadata = await sharp(outputPath).metadata();

      const result: ImageProcessingResult = {
        success: true,
        outputPath,
        width: finalMetadata.width,
        height: finalMetadata.height,
        processingTime: Date.now() - startTime,
      };

      logger.info({ outputPath, processingTime: result.processingTime }, "Image enhancement completed");
      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error({ error: errorMessage, inputPath, config }, "Image enhancement failed");
      
      return {
        success: false,
        error: errorMessage,
        processingTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Prepare image for FramePack compatibility
   * Ensures correct dimensions, format, and aspect ratio
   */
  public async prepareForFramePack(
    inputPath: string,
    outputPath: string,
    orientation: "portrait" | "landscape" = "portrait"
  ): Promise<ImageProcessingResult> {
    const startTime = Date.now();

    try {
      logger.info({ inputPath, outputPath, orientation }, "Preparing image for FramePack");

      await fs.access(inputPath);
      await fs.mkdir(path.dirname(outputPath), { recursive: true });

      const image = sharp(inputPath);
      const metadata = await image.metadata();

      if (!metadata.width || !metadata.height) {
        throw new Error("Unable to determine image dimensions");
      }

      // FramePack works best with specific resolutions
      let targetWidth: number, targetHeight: number;
      
      if (orientation === "portrait") {
        // Common portrait resolutions that work well with FramePack
        targetWidth = 576;  // 9:16 aspect ratio
        targetHeight = 1024;
      } else {
        // Common landscape resolutions
        targetWidth = 1024; // 16:9 aspect ratio  
        targetHeight = 576;
      }

      // Resize and crop to maintain aspect ratio
      let processedImage = image.resize(targetWidth, targetHeight, {
        fit: "cover",
        position: "center",
      });

      // Ensure RGB format (FramePack expects RGB)
      processedImage = processedImage.removeAlpha().toColourspace("srgb");

      // Save as high-quality JPEG
      await processedImage.jpeg({ quality: 95 }).toFile(outputPath);

      const result: ImageProcessingResult = {
        success: true,
        outputPath,
        width: targetWidth,
        height: targetHeight,
        processingTime: Date.now() - startTime,
      };

      logger.info({ outputPath, dimensions: `${targetWidth}x${targetHeight}` }, "Image prepared for FramePack");
      return result;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error({ error: errorMessage, inputPath }, "FramePack preparation failed");
      
      return {
        success: false,
        error: errorMessage,
        processingTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Batch process multiple images
   */
  public async batchProcess(
    inputPaths: string[],
    outputDir: string,
    processor: (inputPath: string, outputPath: string) => Promise<ImageProcessingResult>
  ): Promise<ImageProcessingResult[]> {
    await fs.mkdir(outputDir, { recursive: true });
    
    const results: ImageProcessingResult[] = [];
    
    for (let i = 0; i < inputPaths.length; i++) {
      const inputPath = inputPaths[i];
      const filename = path.basename(inputPath, path.extname(inputPath));
      const outputPath = path.join(outputDir, `${filename}_processed.jpg`);
      
      try {
        const result = await processor(inputPath, outputPath);
        results.push(result);
        logger.info({ inputPath, success: result.success }, `Batch processing ${i + 1}/${inputPaths.length}`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        results.push({
          success: false,
          error: errorMessage,
        });
        logger.error({ inputPath, error: errorMessage }, "Batch processing item failed");
      }
    }
    
    return results;
  }

  /**
   * Get appropriate image dimensions based on config
   */
  private getImageDimensions(config: ImageGenerationConfig): { width: number; height: number } {
    if (config.width && config.height) {
      return { width: config.width, height: config.height };
    }

    if (config.aspectRatio) {
      switch (config.aspectRatio) {
        case "16:9":
          return { width: 1024, height: 576 };
        case "9:16":
          return { width: 576, height: 1024 };
        case "4:3":
          return { width: 1024, height: 768 };
        case "3:4":
          return { width: 768, height: 1024 };
        case "1:1":
        default:
          return { width: 1024, height: 1024 };
      }
    }

    return { width: 1024, height: 1024 };
  }

  /**
   * Get appropriate OpenAI image size
   */
  private getOpenAIImageSize(config: ImageGenerationConfig): string {
    const { width, height } = this.getImageDimensions(config);
    
    // OpenAI supports specific sizes
    if (width === height) return "1024x1024";
    if (width > height) return "1792x1024";
    return "1024x1792";
  }

  /**
   * Extract color suggestions from text prompt
   */
  private extractColorsFromPrompt(prompt: string): { primary: string; secondary: string } {
    const lowerPrompt = prompt.toLowerCase();
    
    // Simple color extraction based on keywords
    if (lowerPrompt.includes("blue") || lowerPrompt.includes("ocean") || lowerPrompt.includes("sky")) {
      return { primary: "#3498db", secondary: "#2980b9" };
    }
    if (lowerPrompt.includes("green") || lowerPrompt.includes("forest") || lowerPrompt.includes("nature")) {
      return { primary: "#27ae60", secondary: "#229954" };
    }
    if (lowerPrompt.includes("red") || lowerPrompt.includes("fire") || lowerPrompt.includes("sunset")) {
      return { primary: "#e74c3c", secondary: "#c0392b" };
    }
    if (lowerPrompt.includes("purple") || lowerPrompt.includes("violet") || lowerPrompt.includes("magic")) {
      return { primary: "#9b59b6", secondary: "#8e44ad" };
    }
    if (lowerPrompt.includes("orange") || lowerPrompt.includes("autumn") || lowerPrompt.includes("warm")) {
      return { primary: "#f39c12", secondary: "#e67e22" };
    }
    
    // Default to a neutral gradient
    return { primary: "#34495e", secondary: "#2c3e50" };
  }

  /**
   * Get information about available image generation services
   */
  public getAvailableServices(): {
    stability: boolean;
    openai: boolean;
    local: boolean;
  } {
    return {
      stability: !!this.stabilityApiKey,
      openai: !!this.openaiApiKey,
      local: true, // Always available as fallback
    };
  }

  /**
   * Validate image for FramePack compatibility
   */
  public async validateForFramePack(imagePath: string): Promise<{
    valid: boolean;
    issues: string[];
    suggestions: string[];
  }> {
    const issues: string[] = [];
    const suggestions: string[] = [];

    try {
      const metadata = await sharp(imagePath).metadata();

      if (!metadata.width || !metadata.height) {
        issues.push("Unable to determine image dimensions");
        return { valid: false, issues, suggestions };
      }

      // Check format
      if (metadata.format !== "jpeg" && metadata.format !== "png") {
        issues.push(`Unsupported format: ${metadata.format}`);
        suggestions.push("Convert to JPEG or PNG format");
      }

      // Check dimensions
      if (metadata.width < 512 || metadata.height < 512) {
        issues.push("Image resolution too low (minimum 512x512)");
        suggestions.push("Upscale image to at least 512x512");
      }

      if (metadata.width > 2048 || metadata.height > 2048) {
        suggestions.push("Consider reducing resolution for faster processing");
      }

      // Check aspect ratio
      const aspectRatio = metadata.width / metadata.height;
      if (aspectRatio < 0.5 || aspectRatio > 2.0) {
        suggestions.push("Extreme aspect ratios may not work well with FramePack");
      }

      // Check file size
      const stats = await fs.stat(imagePath);
      if (stats.size > 10 * 1024 * 1024) { // 10MB
        suggestions.push("Large file size may slow down processing");
      }

      return {
        valid: issues.length === 0,
        issues,
        suggestions,
      };

    } catch (error) {
      issues.push(`Unable to analyze image: ${(error as Error).message}`);
      return { valid: false, issues, suggestions };
    }
  }
}